<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Shong - Shit Pong</title>
<style>
:root {
  --viewport-bg: #101010;
  --court-bg: #000;
  --line-color: #fff;
  --fg: #e6eef8;
}

html, body {
  margin: 0;
  height: 100%;
  overflow: hidden;
}

body {
  background: var(--viewport-bg);
  font-family: "Comic Sans MS", "Comic Sans", cursive;
  position: relative;
  color: var(--fg);
}

.wrap {
  width: 640px;
  height: 360px;
  position: absolute;
  transform-origin: center center;
}

canvas {
  display: block;
  width: 100%;
  height: 100%;
  background: var(--court-bg);
  border-radius: 10px;
  border: 2px solid var(--line-color);
  box-shadow: 0 8px 30px rgba(0, 0, 0, 0.6);
}

.controls {
  position: absolute;
  bottom: -46px;
  left: 0;
  width: 100%;
  display: flex;
  justify-content: space-between;
  padding: 0 8px;
}

.left-controls {
  display: flex;
  gap: 6px;
}

button {
  background: transparent;
  border: 1px solid rgba(230,238,248,0.15);
  padding: 6px 10px;
  border-radius: 8px;
  color: var(--fg);
  cursor: pointer;
  backdrop-filter: blur(4px);
  font-size: 14px;
  font-family: "Comic Sans MS", "Comic Sans", cursive;
}
button:hover {
  background: rgba(255,255,255,0.1);
}
</style>
</head>
<body>
<div class="wrap">
  <canvas id="game"></canvas>
  <div class="controls">
    <div class="left-controls">
      <button id="toggleMoveBtn">Toggle Movement</button>
      <button id="toggleAIBtn">Toggle AI</button>
    </div>
    <button id="resetBtn">Reset</button>
  </div>
</div>

<script>
(() => {
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
const wrapEl = document.querySelector('.wrap');
const resetBtn = document.getElementById('resetBtn');
const toggleMoveBtn = document.getElementById('toggleMoveBtn');
const toggleAIBtn = document.getElementById('toggleAIBtn');

const SCALE = 0.8;
const GAME_W = 800 * SCALE, GAME_H = 450 * SCALE;
const PADDLE_W = 12 * SCALE, PADDLE_H = 90 * SCALE, BALL_R = 8 * SCALE;

function fitCanvas() {
  const rect = canvas.getBoundingClientRect();
  canvas.width = Math.round(rect.width * devicePixelRatio);
  canvas.height = Math.round(rect.height * devicePixelRatio);
  ctx.setTransform(devicePixelRatio, 0, 0, devicePixelRatio, 0, 0);
}
fitCanvas();
new ResizeObserver(fitCanvas).observe(canvas);

const bonkSound = new Audio('sound/bonk.wav');
const springSound = new Audio('sound/spring.wav');

let player = { x: 24 * SCALE, y: (GAME_H - PADDLE_H) / 2, score: 0 };
let cpu = { x: GAME_W - 24 * SCALE - PADDLE_W, y: (GAME_H - PADDLE_H) / 2, score: 0 };
let ball = { x: GAME_W / 2, y: GAME_H / 2, vx: 220 * SCALE, vy: 60 * SCALE, r: BALL_R };

// States
let firstStart = true;
let ballPaused = true;
let aiEnabled = true;
let movementEnabled = true;
let hue = 0, waveTime = 0;

// Court motion
let wrapCenterX = window.innerWidth / 2, wrapCenterY = window.innerHeight / 2;
let wrapVX = 150, wrapVY = 120, wrapRotation = 0, wrapRotationSpeed = 0.5;

// Score motion
const SCORE_FONT_SIZE = 28;
let playerScore = { x: GAME_W*0.25, y:40, vx:40, vy:30, angle:0, angularVelocity:1.5 };
let cpuScore    = { x: GAME_W*0.75, y:40, vx:-50, vy:40, angle:0, angularVelocity:-2 };

function clamp(v, a, b) { return Math.max(a, Math.min(b, v)); }

function drawWavyPaddle(x, y) {
  const amplitude = 3 * SCALE, wavelength = 16 * SCALE;
  const gradient = ctx.createLinearGradient(x, y, x, y + PADDLE_H);
  gradient.addColorStop(0, `hsl(${hue},100%,60%)`);
  gradient.addColorStop(0.5, `hsl(${(hue + 60) % 360},100%,50%)`);
  gradient.addColorStop(1, `hsl(${(hue + 120) % 360},100%,40%)`);
  ctx.beginPath();
  for (let i = 0; i <= PADDLE_H; i++) {
    const offset = Math.sin((i / wavelength) + waveTime * 0.6) * amplitude;
    ctx.lineTo(i === 0 ? x + offset : x + offset, y + i);
  }
  for (let i = PADDLE_H; i >= 0; i--) {
    const offset = Math.sin((i / wavelength) + waveTime * 0.6 + Math.PI) * amplitude;
    ctx.lineTo(x + PADDLE_W + offset, y + i);
  }
  ctx.closePath();
  ctx.fillStyle = gradient;
  ctx.fill();
}

function draw() {
  ctx.clearRect(0, 0, GAME_W, GAME_H);

  // Court
  ctx.fillStyle = "#000";
  ctx.fillRect(0, 0, GAME_W, GAME_H);
  ctx.strokeStyle = "#fff";
  ctx.lineWidth = 2;
  ctx.strokeRect(0, 0, GAME_W, GAME_H);

  // Center dashed line
  ctx.setLineDash([8,12]);
  ctx.beginPath();
  ctx.moveTo(GAME_W/2, 20);
  ctx.lineTo(GAME_W/2, GAME_H-20);
  ctx.stroke();
  ctx.setLineDash([]);

  drawWavyPaddle(player.x, player.y);
  drawWavyPaddle(cpu.x, cpu.y);

  // Ball
  const ballGrad = ctx.createRadialGradient(ball.x, ball.y, ball.r*0.2, ball.x, ball.y, ball.r);
  ballGrad.addColorStop(0, `hsl(${hue},100%,60%)`);
  ballGrad.addColorStop(0.5, `hsl(${(hue+60)%360},100%,50%)`);
  ballGrad.addColorStop(1, `hsl(${(hue+120)%360},100%,40%)`);
  ctx.beginPath();
  ctx.fillStyle = ballGrad;
  ctx.arc(ball.x, ball.y, ball.r, 0, Math.PI*2);
  ctx.fill();

  // Scores
  ctx.fillStyle = "#fff";
  ctx.font = `${SCORE_FONT_SIZE}px "Comic Sans MS"`;
  ctx.textAlign = "center"; ctx.textBaseline = "middle";

  ctx.save();
  ctx.translate(playerScore.x, playerScore.y);
  ctx.rotate(playerScore.angle);
  ctx.fillText(player.score, 0, 0);
  ctx.restore();

  ctx.save();
  ctx.translate(cpuScore.x, cpuScore.y);
  ctx.rotate(cpuScore.angle);
  ctx.fillText(cpu.score, 0, 0);
  ctx.restore();
}

function step(dt) {
  if(ballPaused) return;
  ball.x += ball.vx * dt;
  ball.y += ball.vy * dt;

  if (ball.y - BALL_R < 0) { ball.y = BALL_R; ball.vy *= -1; }
  if (ball.y + BALL_R > GAME_H) { ball.y = GAME_H - BALL_R; ball.vy *= -1; }

  if (ball.x - BALL_R < player.x + PADDLE_W && ball.y > player.y && ball.y < player.y + PADDLE_H) {
    ball.x = player.x + PADDLE_W + BALL_R;
    const rel = (ball.y - (player.y + PADDLE_H/2)) / (PADDLE_H/2);
    const angle = rel * (Math.PI/3);
    const speed = Math.hypot(ball.vx, ball.vy) * 1.03;
    ball.vx = speed*Math.cos(angle); ball.vy = speed*Math.sin(angle);
    bonkSound.play();
  }
  if (ball.x + BALL_R > cpu.x && ball.y > cpu.y && ball.y < cpu.y + PADDLE_H) {
    ball.x = cpu.x - BALL_R;
    const rel = (ball.y - (cpu.y + PADDLE_H/2)) / (PADDLE_H/2);
    const angle = rel * (Math.PI/3);
    const speed = Math.hypot(ball.vx, ball.vy) * 1.03;
    ball.vx = -speed*Math.cos(angle); ball.vy = speed*Math.sin(angle);
    bonkSound.play();
  }

  if (ball.x < 0) { cpu.score++; resetBall(true); }
  if (ball.x > GAME_W) { player.score++; resetBall(false); }

  if (aiEnabled) {
    const target = ball.y - PADDLE_H/2;
    const diff = target - cpu.y;
    const aiSpeed = 220*SCALE + Math.min(160*SCALE, Math.abs(ball.vx));
    cpu.y += clamp(diff,-aiSpeed*dt,aiSpeed*dt);
  }

  player.y = clamp(player.y, 0, GAME_H-PADDLE_H);
  cpu.y = clamp(cpu.y, 0, GAME_H-PADDLE_H);
}

function handlePlayer(dt){
  if(ballPaused) return;
  const speed=300*SCALE;
  if(keys['w']||keys['arrowup'])player.y-=speed*dt;
  if(keys['s']||keys['arrowdown'])player.y+=speed*dt;
}

function resetBall(toPlayer) {
  ball.x = GAME_W/2; ball.y = GAME_H/2;
  const angle = (Math.random()*Math.PI/3 - Math.PI/6);
  const speed = 220*SCALE;
  const dir = toPlayer?-1:1;
  ball.vx = speed*Math.cos(angle)*dir;
  ball.vy = speed*Math.sin(angle);
}

const keys = {};
window.addEventListener('keydown', e => {
  keys[e.key.toLowerCase()] = true;
  if(e.code === 'Space'){
    if(firstStart){
      firstStart = false;
      ballPaused = false;
    } else {
      ballPaused = !ballPaused;
    }
  }
});
window.addEventListener('keyup', e => { keys[e.key.toLowerCase()] = false; });

function getRotatedBBox(w,h,angle){const sin=Math.abs(Math.sin(angle)),cos=Math.abs(Math.cos(angle));return {w:w*cos+h*sin,h:w*sin+h*cos};}

function updateScoreMotion(dt){
  if(!movementEnabled || firstStart) return;
  const halfW = GAME_W/2;
  playerScore.x += playerScore.vx*dt; playerScore.y += playerScore.vy*dt; playerScore.angle += playerScore.angularVelocity*dt;
  if(playerScore.x-20<0){playerScore.x=20;playerScore.vx*=-1;}
  if(playerScore.x+20>halfW){playerScore.x=halfW-20;playerScore.vx*=-1;}
  if(playerScore.y-28<0){playerScore.y=28;playerScore.vy*=-1;}
  if(playerScore.y+10>GAME_H){playerScore.y=GAME_H-10;playerScore.vy*=-1;}

  cpuScore.x += cpuScore.vx*dt; cpuScore.y += cpuScore.vy*dt; cpuScore.angle += cpuScore.angularVelocity*dt;
  if(cpuScore.x-20<halfW){cpuScore.x=halfW+20;cpuScore.vx*=-1;}
  if(cpuScore.x+20>GAME_W){cpuScore.x=GAME_W-20;cpuScore.vx*=-1;}
  if(cpuScore.y-28<0){cpuScore.y=28;cpuScore.vy*=-1;}
  if(cpuScore.y+10>GAME_H){cpuScore.y=GAME_H-10;cpuScore.vy*=-1;}
}

let lastTime=null;
function loop(ts){
  if(!lastTime)lastTime=ts;
  const dt=(ts-lastTime)/1000; lastTime=ts;

  waveTime+=dt*10; hue=(hue+120*dt)%360;
  handlePlayer(dt); step(dt); 

  if(movementEnabled && !firstStart){
    wrapRotation += wrapRotationSpeed*dt;
    const bbox=getRotatedBBox(GAME_W,GAME_H,wrapRotation);
    const halfW=bbox.w/2, halfH=bbox.h/2;
    wrapCenterX += wrapVX*dt; wrapCenterY += wrapVY*dt;

    if(wrapCenterX-halfW<0){wrapVX*=-1; wrapCenterX=halfW;}
    if(wrapCenterX+halfW>window.innerWidth){wrapVX*=-1; wrapCenterX=window.innerWidth-halfW;}
    if(wrapCenterY-halfH<0){wrapVY*=-1; wrapCenterY=halfH;}
    // Fixed bottom edge collision
    if(wrapCenterY+halfH>window.innerHeight){wrapVY*=-1; wrapCenterY=window.innerHeight-halfH;}

    updateScoreMotion(dt);
  }

  draw();
  wrapEl.style.transform=`translate(${wrapCenterX-GAME_W/2}px,${wrapCenterY-GAME_H/2}px) rotate(${wrapRotation}rad)`;
  requestAnimationFrame(loop);
}

// Reset reloads the page
resetBtn.addEventListener('click', () => { location.reload(); });
toggleMoveBtn.addEventListener('click', ()=>{movementEnabled=!movementEnabled;});
toggleAIBtn.addEventListener('click', ()=>{aiEnabled=!aiEnabled;});

requestAnimationFrame(loop);
})();
</script>
</body>
</html>
